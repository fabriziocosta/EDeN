#!/usr/bin/env python
import os
import logging

from eden.model_base import ModelInitializerBase, main_script
from eden.converter.molecule import obabel
from eden.graph import Vectorizer

description = """
Explicit Decomposition with Neighborhood (EDeN) utility program.
Model driver.

Example usage:
- for fitting a predictive model:
model -vv fit --cv 5 --scoring 'f1'  --n-active-learning-iterations 3
--size-negative 50 -p pos_train.nx -n neg_train.nx -j 8 -e 20 --model-file mod
 --output-dir out

-for predicting using a fit model:
model -vv predict -i test.nx --model-file out/mod



Note: the current implementation uses as estimator a regularized linear model
with stochastic  gradient descent (SGD) learning scheme: the gradient of the
loss is estimated each sample at  a time and the model is updated along the way
with a decreasing strength schedule (aka learning rate). """

epilog = """
Authors: Fabrizio Costa, Jose Luis Licon
Copyright: 2015
License: GPL
Maintainer: Fabrizio Costa
Email: costa@informatik.uni-freiburg.de, liconj@informatik.uni-freiburg.de
Status: Production

Cite:  Costa, Fabrizio, and Kurt De Grave, 'Fast neighborhood subgraph pairwise
distance kernel', Proceedings of the 26th International Conference on Machine
Learning. 2010. """


class ModelInitializer(ModelInitializerBase):

    def __init__(self):
        pass

    def load_data(self, args, data):
        file_format = args.format
        iterator = obabel.make_iterable(data, file_format)
        return iterator

    def load_positive_data(self, args):
        iterator = self.load_data(args, args.positive_input_file)
        return iterator

    def load_negative_data(self, args):
        iterator = self.load_data(args, args.negative_input_file)
        return iterator

    def pre_processor_init(self, args):

        model_type = args.mode

        if model_type == "default":

            def pre_processor(data, model_type="default", **kwargs):
                iterable = obabel.obabel_to_eden(data, **kwargs)
                return iterable

            pre_processor_parameters = {}

        elif model_type == "3d":

            def pre_processor(data, model_type="3d", **kwargs):
                iterable = obabel.obabel_to_eden3d(data, **kwargs)
                return iterable

            pre_processor_parameters = \
                {'k': [args.n_neighbors],
                 'threshold': [args.threshold],
                 'model_type': [model_type],
                 'n_conf': [args.n_conf]}

        return pre_processor, pre_processor_parameters

    def vectorizer_init(self, args):
        """Setup the conversion of graphs generated by the the pre_processor
        function to feature vectors.

        Returns the function used to calculate feature vectors from graphs
        prepared by the
        pre_processor function and a set of matching parameter choices.
        """
        from math import sqrt

        # Get the number of positive data points to use in calculating the max
        # value of n

        pos_size = len(list(self.load_positive_data(args)))
        max_n = int(round(sqrt(pos_size)))
        vectorizer = Vectorizer()
        vectorizer_parameters = {'complexity': [2, 4],
                                 'n': [max_n],
                                 'label_size': [5]}
        return vectorizer, vectorizer_parameters

    def add_arguments(self, parser):
        parser.add_argument('--version', action='version', version='0.1')
        return parser

    def add_arguments_fit(self, parser):
        parser.add_argument("-p", "--positive-input-file",
                            dest="positive_input_file",
                            help="Path to file containing input for the \
                                  positive class.",
                            required=True)
        parser.add_argument("-n", "--negative-input-file",
                            dest="negative_input_file",
                            help="Path to file containing input for the \
                                  negative class.",
                            required=True)
        parser.add_argument("--n-neighbors",
                            default=3,
                            type=int,
                            help="Number of nearest graph elements to be \
                                  considered.")
        parser.add_argument("--threshold",
                            default=10,
                            type=int,
                            help="Distance beyond which the graph elements are \
                                  not considered any more.")
        parser.add_argument("--mode",
                            default="3d",
                            help="Default or 3D model.")
        parser.add_argument("--n-conf",
                            default=10,
                            type=int,
                            help="Number of conformers to be calculated for \
                                  each molecule.")
        parser.add_argument("--format",
                            default="sdf",
                            help="Format of the input files.")

        return parser

    def add_arguments_estimate(self, parser):
        return self.add_arguments_fit(parser)

    def add_arguments_base(self, parser):
        parser.add_argument("-i", "--input-file",
                            dest="input_file",
                            help="Path to file containing input.",
                            required=True)
        return parser

if __name__ == "__main__":
    model_initializer = ModelInitializer()
    main_script(model_initializer=model_initializer,
                description=description,
                epilog=epilog,
                prog_name=os.path.basename(__file__),
                logger=logging.getLogger())
