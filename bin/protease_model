#!/usr/bin/env python

DESCRIPTION = """
Explicit Decomposition with Neighborhood (EDeN) utility program.
Protease modelling driver. 


Note: the current implementation uses as estimator a regularized linear model
with stochastic  gradient descent (SGD) learning scheme: the gradient of the
loss is estimated each sample at  a time and the model is updated along the way
with a decreasing strength schedule (aka learning rate). """

EPILOG = """
Author: Fabrizio Costa
Copyright: 2015
License: GPL
Maintainer: Fabrizio Costa
Email: costa@informatik.uni-freiburg.de
Status: Production

Cite:  Costa, Fabrizio, and Kurt De Grave, 'Fast neighborhood subgraph pairwise
distance kernel', Proceedings of the 26th International Conference on Machine
Learning. 2010. """

from eden.model_base import *


class ModelInitializer(ModelInitializerBase):

    def __init__(self):
        pass

    def load_data(self, args):
        from eden.converter.fasta import fasta_to_sequence
        seqs = fasta_to_sequence(args.input_file)
        return seqs

    def load_positive_data(self, args):
        return self.load_data(args)

    def load_negative_data(self, args):
        seqs = self.load_data(args)
        from eden.modifier.seq import seq_to_seq, shuffle_modifier
        return seq_to_seq(seqs, modifier=shuffle_modifier, times=args.negative_ratio, order=args.shuffle_order)

    def pre_processor_init(self, n_iter):
        def pre_processor(seqs, **args):
            # insert landmark in the cleavage site after pos 4, in our case this means always in the middle position
            from eden.modifier.seq import seq_to_seq, mark_modifier
            seqs = seq_to_seq(seqs, modifier=mark_modifier, position=0.5, mark='%')
            seqs = seq_to_seq(seqs, modifier=mark_modifier, position=0.0, mark='@')
            seqs = seq_to_seq(seqs, modifier=mark_modifier, position=1.0, mark='*')
            # convert to graph
            from eden.converter.fasta import sequence_to_eden
            graphs = sequence_to_eden(seqs)
            return graphs

        pre_processor_parameters = {}
        return pre_processor, pre_processor_parameters

    def vectorizer_init(self, n_iter):
        vectorizer = Vectorizer()
        vectorizer_parameters = {'complexity': [2, 3, 4, 5, 6]}
        return vectorizer, vectorizer_parameters

    def add_arguments_fit(self, parser):
        parser.add_argument("-i", "--input-file",
                            dest="input_file",
                            help="Path to FASTA file containing input sequences.",
                            required=True)
        parser.add_argument("--negative-ratio",
                            dest="negative_ratio",
                            type=int,
                            help="Relative size ration for the randomly permuted negative instances w.r.t. the positive instances.",
                            default=2)
        parser.add_argument("--shuffle-order",
                            dest="shuffle_order",
                            type=int,
                            help="Order of the k-mer for the random shuffling procedure.",
                            default=2)
        return parser

    def add_arguments_estimate(self, parser):
        parser.add_argument("-i", "--input-file",
                            dest="input_file",
                            help="Path to file containing input.",
                            required=True)
        return parser




if __name__ == "__main__":
    start_time = time()

    model_initializer = ModelInitializer()
    parser = argparse_setup(model_initializer, DESCRIPTION, EPILOG)
    args = parser.parse_args()

    if args.no_logging:
        logger = configure_logging(verbosity=args.verbosity)
    else:
        logger = configure_logging(verbosity=args.verbosity, filename='%s.log' % (os.path.basename(__file__)))

    logger.debug('-' * 80)
    logger.debug('Program: %s' % os.path.basename(__file__))
    logger.debug('Called with parameters:\n %s' % serialize_dict(args.__dict__))
    try:
        main(model_initializer, args)
    except Exception:
        import datetime
        curr_time = datetime.datetime.now().strftime("%A, %d. %B %Y %I:%M%p")
        logger.exception("Program run failed on %s" % curr_time)
    finally:
        end_time = time()
        logger.info('Elapsed time: %.1f sec', end_time - start_time)