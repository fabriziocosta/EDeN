#!/usr/bin/env python
import os
import logging
from math import sqrt

from eden.model_base import ModelInitializerBase, main_script
from eden.converter.molecule import obabel
from eden.graph import Vectorizer

description = """
Explicit Decomposition with Neighborhood (EDeN) utility program.
Model driver.

Example usage:
- for fitting a predictive model:
model -vv fit --cv 5 --scoring 'f1'  --n-active-learning-iterations 3
--size-negative 50 -p pos_train.nx -n neg_train.nx -j 8 -e 20 --model-file mod
 --output-dir out

-for predicting using a fit model:
model -vv predict -i test.nx --model-file out/mod



Note: the current implementation uses as estimator a regularized linear model
with stochastic  gradient descent (SGD) learning scheme: the gradient of the
loss is estimated each sample at  a time and the model is updated along the way
with a decreasing strength schedule (aka learning rate). """

epilog = """
Authors: Fabrizio Costa, Jose Luis Licon
Copyright: 2015
License: GPL
Maintainer: Fabrizio Costa
Email: costa@informatik.uni-freiburg.de, liconj@informatik.uni-freiburg.de
Status: Production

Cite:  Costa, Fabrizio, and Kurt De Grave, 'Fast neighborhood subgraph pairwise
distance kernel', Proceedings of the 26th International Conference on Machine
Learning. 2010. """


class ModelInitializer(ModelInitializerBase):

    def __init__(self):
        pass

    def load_data(self, args, data):
        file_format = args.format
        iterator = obabel.mol_file_to_iterable(data, file_format)
        return iterator

    def load_positive_data(self, args):
        iterator = self.load_data(args, args.positive_input_file)
        return iterator

    def load_negative_data(self, args):
        iterator = self.load_data(args, args.negative_input_file)
        return iterator

    def pre_processor_init(self, args):

        model_type = args.mode
        model_method = args.method

        if model_type == "default":

            def pre_processor(data, model_type="default", **kwargs):
                iterable = obabel.obabel_to_eden(data, **kwargs)
                return iterable

            pre_processor_parameters = {}

        elif model_type == "3d":

            def pre_processor(data, model_type="3d", **kwargs):
                iterable = obabel.obabel_to_eden3d(data, method=model_method, **kwargs)
                return iterable

            if model_method == "metric":
                if args.hyper_opt:
                    pre_processor_parameters = \
                        {'k': range(1, 11),
                         'threshold': range(1, 11),
                         'model_type': [model_type],
                         'n_conf': [args.n_conf]}
                else:
                    pre_processor_parameters = \
                        {'k': [args.n_neighbors],
                         'threshold': [args.threshold],
                         'model_type': [model_type],
                         'n_conf': [args.n_conf]}
            elif model_method == "topological":
                pre_processor_parameters = {'n_conf': [args.n_conf]}

        return pre_processor, pre_processor_parameters

    def vectorizer_init(self, args):
        """Setup the conversion of graphs generated by the the pre_processor
        function to feature vectors.

        Returns the function used to calculate feature vectors from graphs
        prepared by the
        pre_processor function and a set of matching parameter choices.
        """

        # Get the number of positive data points to use in calculating the max
        # value of n

        pos_size = len(list(self.load_positive_data(args)))
        max_n = int(round(sqrt(pos_size)))
        vectorizer = Vectorizer()
        vectorizer_parameters = {'complexity': [2, 4],
                                 'n': [max_n],
                                 'label_size': [5, 10]}
        return vectorizer, vectorizer_parameters

    def add_arguments(self, parser):
        parser.add_argument('--version', action='version', version='0.1')
        return parser

    def add_arguments_fit(self, parser):
        parser.add_argument("-p", "--positive-input-file",
                            dest="positive_input_file",
                            help="Path to file containing input for the \
                                  positive class.",
                            required=True)
        parser.add_argument("-n", "--negative-input-file",
                            dest="negative_input_file",
                            help="Path to file containing input for the \
                                  negative class.",
                            required=True)
        parser.add_argument("--n-neighbors",
                            default=3,
                            type=int,
                            help="Number of nearest graph elements to be \
                                  considered.")
        parser.add_argument("--threshold",
                            default=10,
                            type=int,
                            help="Distance beyond which the graph elements are \
                                  not considered any more.")
        parser.add_argument("--mode",
                            default="3d",
                            help="Default or 3D model.")
        parser.add_argument("--method",
                            default="metric",
                            help="Method to calculate the vector labels - metric or topological.")
        parser.add_argument("--n-conf",
                            default=10,
                            type=int,
                            help="Number of conformers to be calculated for \
                                  each molecule.")
        parser.add_argument("--format",
                            default="sdf",
                            help="Format of the input files.")
        parser.add_argument("--hyper-opt",
                            dest='hyper_opt',
                            action='store_true',
                            default=False,
                            help="Whether to perform hyper-parameter optimization \
                            in the pre-processor")

        return parser

    def add_arguments_estimate(self, parser):
        return self.add_arguments_fit(parser)

    def add_arguments_base(self, parser):
        parser.add_argument("-i", "--input-file",
                            dest="input_file",
                            help="Path to file containing input.",
                            required=True)
        return parser

if __name__ == "__main__":
    model_initializer = ModelInitializer()
    main_script(model_initializer=model_initializer,
                description=description,
                epilog=epilog,
                prog_name=os.path.basename(__file__),
                logger=logging.getLogger())
